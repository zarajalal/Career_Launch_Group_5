"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TabBarItem = TabBarItem;
var React = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _useLatestCallback = _interopRequireDefault(require("use-latest-callback"));
var _PlatformPressable = require("./PlatformPressable.js");
var _TabBarItemLabel = require("./TabBarItemLabel.js");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const DEFAULT_ACTIVE_COLOR = 'rgba(255, 255, 255, 1)';
const DEFAULT_INACTIVE_COLOR = 'rgba(255, 255, 255, 0.7)';
const ICON_SIZE = 24;
const getActiveOpacity = (position, routesLength, tabIndex) => {
  if (routesLength > 1) {
    const inputRange = Array.from({
      length: routesLength
    }, (_, i) => i);
    return position.interpolate({
      inputRange,
      outputRange: inputRange.map(i => i === tabIndex ? 1 : 0)
    });
  } else {
    return 1;
  }
};
const getInactiveOpacity = (position, routesLength, tabIndex) => {
  if (routesLength > 1) {
    const inputRange = Array.from({
      length: routesLength
    }, (_, i) => i);
    return position.interpolate({
      inputRange,
      outputRange: inputRange.map(i => i === tabIndex ? 0 : 1)
    });
  } else {
    return 0;
  }
};
const ANDROID_RIPPLE_DEFAULT = {
  borderless: true
};
const TabBarItemInternal = ({
  accessibilityLabel,
  accessible,
  label: customlabel,
  testID,
  onLongPress,
  onPress,
  isFocused,
  position,
  style,
  inactiveColor: inactiveColorCustom,
  activeColor: activeColorCustom,
  labelStyle,
  onLayout,
  index: tabIndex,
  pressColor,
  pressOpacity,
  defaultTabWidth,
  icon: customIcon,
  badge: customBadge,
  href,
  labelText,
  routesLength,
  android_ripple = ANDROID_RIPPLE_DEFAULT,
  labelAllowFontScaling,
  route
}) => {
  const labelColorFromStyle = _reactNative.StyleSheet.flatten(labelStyle || {}).color;
  const activeColor = activeColorCustom !== undefined ? activeColorCustom : typeof labelColorFromStyle === 'string' ? labelColorFromStyle : DEFAULT_ACTIVE_COLOR;
  const inactiveColor = inactiveColorCustom !== undefined ? inactiveColorCustom : typeof labelColorFromStyle === 'string' ? labelColorFromStyle : DEFAULT_INACTIVE_COLOR;
  const activeOpacity = getActiveOpacity(position, routesLength, tabIndex);
  const inactiveOpacity = getInactiveOpacity(position, routesLength, tabIndex);
  const icon = React.useMemo(() => {
    if (!customIcon) {
      return null;
    }
    const inactiveIcon = customIcon({
      focused: false,
      color: inactiveColor,
      size: ICON_SIZE,
      route
    });
    const activeIcon = customIcon({
      focused: true,
      color: activeColor,
      size: ICON_SIZE,
      route
    });
    return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
      style: styles.icon,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
        style: {
          opacity: inactiveOpacity
        },
        children: inactiveIcon
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
        style: [_reactNative.StyleSheet.absoluteFill, {
          opacity: activeOpacity
        }],
        children: activeIcon
      })]
    });
  }, [activeColor, activeOpacity, customIcon, inactiveColor, inactiveOpacity, route]);
  const renderLabel = React.useCallback(focused => customlabel ? customlabel({
    focused,
    color: focused ? activeColor : inactiveColor,
    style: labelStyle,
    labelText,
    allowFontScaling: labelAllowFontScaling,
    route
  }) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_TabBarItemLabel.TabBarItemLabel, {
    color: focused ? activeColor : inactiveColor,
    icon: icon,
    label: labelText,
    style: labelStyle
  }), [customlabel, activeColor, labelStyle, labelText, labelAllowFontScaling, route, inactiveColor, icon]);
  const tabStyle = _reactNative.StyleSheet.flatten(style);
  const isWidthSet = tabStyle?.width !== undefined;
  const tabContainerStyle = isWidthSet ? null : {
    width: defaultTabWidth
  };
  accessibilityLabel = typeof accessibilityLabel !== 'undefined' ? accessibilityLabel : labelText;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_PlatformPressable.PlatformPressable, {
    android_ripple: android_ripple,
    testID: testID,
    accessible: accessible,
    accessibilityLabel: accessibilityLabel,
    accessibilityRole: "tab",
    accessibilityState: {
      selected: isFocused
    },
    pressColor: pressColor,
    pressOpacity: pressOpacity,
    unstable_pressDelay: 0,
    onLayout: onLayout,
    onPress: onPress,
    onLongPress: onLongPress,
    href: href,
    style: [styles.pressable, tabContainerStyle],
    children: /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
      pointerEvents: "none",
      style: [styles.item, tabStyle],
      children: [icon, /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNative.View, {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
          style: {
            opacity: inactiveOpacity
          },
          children: renderLabel(false)
        }), /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.Animated.View, {
          style: [_reactNative.StyleSheet.absoluteFill, {
            opacity: activeOpacity
          }],
          children: renderLabel(true)
        })]
      }), customBadge != null ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNative.View, {
        style: styles.badge,
        children: customBadge({
          route
        })
      }) : null]
    })
  });
};
const MemoizedTabBarItemInternal = /*#__PURE__*/React.memo(TabBarItemInternal);
function TabBarItem(props) {
  const {
    onPress,
    onLongPress,
    onLayout,
    navigationState,
    route,
    ...rest
  } = props;
  const onPressLatest = (0, _useLatestCallback.default)(onPress);
  const onLongPressLatest = (0, _useLatestCallback.default)(onLongPress);
  const onLayoutLatest = (0, _useLatestCallback.default)(onLayout ? onLayout : () => {});
  const tabIndex = navigationState.routes.indexOf(route);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(MemoizedTabBarItemInternal, {
    ...rest,
    onPress: onPressLatest,
    onLayout: onLayoutLatest,
    onLongPress: onLongPressLatest,
    isFocused: navigationState.index === tabIndex,
    route: route,
    index: tabIndex,
    routesLength: navigationState.routes.length
  });
}
const styles = _reactNative.StyleSheet.create({
  icon: {
    margin: 2
  },
  item: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 10,
    minHeight: 48
  },
  badge: {
    position: 'absolute',
    top: 0,
    end: 0
  },
  pressable: {
    // The label is not pressable on Windows
    // Adding backgroundColor: 'transparent' seems to fix it
    backgroundColor: 'transparent',
    ..._reactNative.Platform.select({
      // Roundness for iPad hover effect
      ios: {
        borderRadius: 10
      },
      default: null
    })
  }
});
//# sourceMappingURL=TabBarItem.js.map